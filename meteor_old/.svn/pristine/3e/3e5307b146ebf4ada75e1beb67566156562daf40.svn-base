#include <stdlib.h>#include <string.h>#include <time.h>#include <stdio.h>#include <fcntl.h>#include <stdarg.h>#include <unistd.h>#include "meteor.h"#include "sockd.h"#include "log.h"static struct log_struct *s_sys_log_st = NULL;static struct log_struct *s_flow_log_st = NULL;static char *level_string[] = { " NONE ", " FLOW ", " ERROR ", " WARNING ", " NOTICE ", " INFO ", " DEBUG " };static struct log_struct * _log_init(int mode, int level, char * path, int rotate_interval );static int _log_rotate( struct log_struct *log_st, time_t now, struct tm *ptime );static int _log_print( struct log_struct *log_st, time_t now, struct tm *ptime, char *msg );extern socks_module_config_t g_config;int log_init( int listen_port){	struct log_struct *log_st;	if( strlen(g_config.sys_log_file_name) == 0 )		strcpy(g_config.sys_log_file_name, SYS_LOG_DEFAULT_PATH );	if( g_config.sys_log_mode == 0 )		g_config.sys_log_mode = LOG_MODE_FILE;	if( g_config.sys_log_level == 0 )		g_config.sys_log_level = LL_ERROR;	if( g_config.sys_log_rotate_interval == 0 )		g_config.sys_log_rotate_interval = SECONDS_OF_ONE_DAY;	char path[FILE_NAME_LEN]={0};		if( listen_port )		sprintf( path, "%s.%d", g_config.sys_log_file_name, listen_port );	else		sprintf( path, "%s", g_config.sys_log_file_name, listen_port );		log_st = _log_init( g_config.sys_log_mode, g_config.sys_log_level, path, g_config.sys_log_rotate_interval );	if (log_st == NULL)		return -1;		s_sys_log_st = log_st;	if(listen_port){		if( strlen(g_config.flow_log_file_name) == 0 )			strcpy(g_config.flow_log_file_name, FLOW_LOG_DEFAULT_PATH );				if( g_config.flow_log_rotate_interval == 0 )			g_config.flow_log_rotate_interval = SECONDS_OF_ONE_DAY;		sprintf( path, "%s.%d", g_config.flow_log_file_name, listen_port );		log_st = _log_init( LOG_MODE_FILE, LL_FLOW, path, g_config.flow_log_rotate_interval );		if (log_st == NULL)			return -1;				s_flow_log_st = log_st;	}		return 0;}void log_exit(void){	if (s_sys_log_st != NULL) {		pthread_mutex_destroy(&s_sys_log_st->lock);		close(s_sys_log_st->fd);		free(s_sys_log_st);	}	if (s_flow_log_st != NULL) {		pthread_mutex_destroy(&s_flow_log_st->lock);		close(s_flow_log_st->fd);		free(s_flow_log_st);	}}int sys_log( int level, const char *format, ...){	if (level > s_sys_log_st->level)		return 0;	time_t now = time(NULL);	struct tm *ptime = localtime(&now);	char tmp[64];	int len = 0;	char buf[2048];	if (strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S ", ptime)) {		len = snprintf(buf, sizeof(buf), "%s[%s] ", tmp, level_string[level]);	}			va_list ap;	va_start(ap, format);	vsnprintf(buf + len, sizeof(buf) - len, format, ap);	va_end(ap);	strcat( buf, "\n" );	return _log_print(s_sys_log_st, now, ptime, buf );}int flow_log( const char *format, ...){	time_t now = time(NULL);	struct tm *ptime = localtime(&now);	char tmp[64];	int len = 0;	char buf[2048];	if (strftime(tmp, sizeof(tmp), "%Y-%m-%d %H:%M:%S", ptime)) {		len = snprintf(buf, sizeof(buf), "%s ", tmp );	}			va_list ap;	va_start(ap, format);	vsnprintf(buf + len, sizeof(buf) - len, format, ap);	va_end(ap);	strcat( buf, "\n" );		return _log_print( s_flow_log_st, now, ptime, buf );}int log_rotate( struct log_struct *log_st ){	pthread_mutex_lock(&log_st->lock);	time_t now = time(NULL);	struct tm *ptime = localtime(&now);	int ret = _log_rotate( log_st, now, ptime );	pthread_mutex_unlock(&log_st->lock);	return ret;}static struct log_struct * _log_init(int mode, int level, char * path, int rotate_interval ){	struct log_struct *log_st;	log_st = calloc(1, sizeof(struct log_struct));	if (log_st == NULL)		return NULL;		memset((void *)log_st, 0, sizeof(struct log_struct));	log_st->mode = mode;	log_st->level = level;		strncpy(log_st->path, path, strlen(path));	log_st->fd = open( log_st->path, O_WRONLY|O_APPEND | O_CREAT );		pthread_mutex_init(&log_st->lock, NULL);  	long now = time(NULL);	if( rotate_interval == SECONDS_OF_ONE_DAY )		log_st->rotate_last_stamp = get_mid_night_second(now);	else		log_st->rotate_last_stamp = now - (now % rotate_interval );	log_st->rotate_interval = rotate_interval;	return log_st;}#if 0  static struct log_struct * _multi_process_log_init(int mode, int level, char * path, int rotate_interval ){	struct log_struct *log_st;	log_st = calloc(1, sizeof(struct log_struct));	if (log_st == NULL)		return NULL;		memset((void *)log_st, 0, sizeof(struct log_struct));	log_st->mode = mode;	log_st->level = level;		strncpy(log_st->path, path, sizeof(log_st->path));	log_st->fd = open( log_st->path, O_WRONLY|O_APPEND | O_CREAT );		pthread_mutex_init(&log_st->lock, NULL);	#if 0  	//设置为进程共享    pthread_mutexattr_init(&log_st->lock_attr);      pthread_mutexattr_setpshared(&log_st->lock_attr,PTHREAD_PROCESS_SHARED);                pthread_mutex_init(&log_st->lock,&log_st->lock_attr);      //匿名内存映射，让父子进程都操作ptr指向的内存区，如果不使用共享内存，则父子进程的ptr指向的是各自的内存空间      ptr = (PFOO)mmap(NULL,sizeof(FOO),PROT_READ | PROT_WRITE,MAP_SHARED|MAP_ANON,-1,0);   	#endif	long now = time(NULL);	if( rotate_interval == SECONDS_OF_ONE_DAY )		log_st->rotate_last_stamp = get_mid_night_second(now);	else		log_st->rotate_last_stamp = now - (now % rotate_interval );	log_st->rotate_interval = rotate_interval;	return log_st;}#endifstatic int _log_rotate( struct log_struct *log_st, time_t now, struct tm *ptime ){	if(log_st->fd<0 || (now-log_st->rotate_interval) < log_st->rotate_last_stamp )		return 0;		char path[1024];	memset( path, 0, sizeof(path) );	snprintf(path, sizeof(path), "%s.%d%02d%02d%02d%02d", log_st->path,		ptime->tm_year + 1900, ptime->tm_mon + 1, ptime->tm_mday, ptime->tm_hour, ptime->tm_min );	fflush(NULL);	close(log_st->fd );	if( rename( log_st->path, path )<0 )		return -1;	log_st->fd = open( log_st->path, O_WRONLY|O_APPEND | O_CREAT );	if( log_st->fd< 0)		return -1;	if( log_st->rotate_interval == SECONDS_OF_ONE_DAY )		log_st->rotate_last_stamp = get_mid_night_second(now);	else		log_st->rotate_last_stamp = now - (now % log_st->rotate_interval );	return 0;}static int _log_print( struct log_struct *log_st, time_t now, struct tm *ptime, char *msg ){	ASSERT(log_st != NULL);	int ret = 0;		//printf("%s\n",msg );	//pthread_mutex_lock(&log_st->lock);	switch (log_st->mode) {		case LOG_MODE_NONE:			break;		case LOG_MODE_SYSTEM:			break;		case LOG_MODE_CONSOLE:			printf("%s\n",msg );			//fprintf(stdout, "%s\n", msg);			break;		case LOG_MODE_FILE:			if (log_st->fd < 0)			{				log_st->fd = open( log_st->path, O_WRONLY|O_APPEND | O_CREAT );			}						if( _log_rotate( log_st, now, ptime ) <0 )				ret = -2;						if (log_st->fd > 0) {				if( write(log_st->fd, msg, strlen(msg))<0 ){					fprintf(stderr, "write log:%s failed. %s", log_st->path, strerror(errno) );					if( errno == ENOSPC )						log_st->disk_full_stamp = now;				}				else if(log_st->disk_full_stamp !=0 )					log_st->disk_full_stamp = 0;								//write(log_st->fd, "\n", strlen("\n"));				//printf("%s\n",msg );				fflush(NULL);			}			else				ret = -1;						break;		default:			ASSERT(0);			break;	}	//pthread_mutex_unlock(&log_st->lock);	return ret;}long get_disk_full_stamp_of_flow_log(){	if( s_flow_log_st )		return s_flow_log_st->disk_full_stamp;	return 0;}long get_disk_full_stamp_of_sys_log(){	if( s_sys_log_st )		return s_sys_log_st->disk_full_stamp;	return 0;}long get_disk_full_stamp_of_log(){	if( s_sys_log_st && s_sys_log_st->disk_full_stamp>0 )		return s_sys_log_st->disk_full_stamp;	if( s_flow_log_st && s_flow_log_st->disk_full_stamp>0 )		return s_flow_log_st->disk_full_stamp;	return 0;}